# streamlit_video_studio.py
"""
Streamlit Video Studio ‚Äî Stable Release for Streamlit Community Cloud

Improvements in this version:
- Diagnostic / System Check page (ffmpeg, codecs, MoviePy, WebRTC availability hints)
- Automatic re-encode & normalization (fps, codec, resolution) using ffmpeg subprocess
- Safer error handling and retries for heavy operations
- Fallbacks for browser features (screen recording / media permissions) with clear UI instructions
- Optimizations for memory and CPU: streaming writes, temp file cleanup, size checks
- Deployment-friendly for Streamlit Community Cloud (requirements.txt created separately).

Notes before deploy to Streamlit Community Cloud:
- Ensure you add `ffmpeg` to the Streamlit Community Cloud build (Streamlit Cloud provides ffmpeg on many stacks; if not available, choose an image that includes it or deploy elsewhere). If ffmpeg is missing at runtime, the Diagnostic page will show guidance.
- Keep an eye on RAM/cpu for long videos ‚Äî Community Cloud has limits. This app is tuned for short/medium clips (<= 2 minutes) by default.

Author: Generated by ChatGPT (GPT-5 Thinking mini)
Date: 2025-11-20
"""

import streamlit as st
from streamlit_webrtc import webrtc_streamer, VideoTransformerBase, RTCConfiguration
import av
import tempfile
import os
import uuid
from moviepy.editor import VideoFileClip, concatenate_videoclips, AudioFileClip, CompositeVideoClip, vfx
from moviepy.video.fx.all import crop
from PIL import Image
import numpy as np
import base64
import io
import shutil
from datetime import datetime
import subprocess
import sys
import json

# === Config & Constants ===
st.set_page_config(page_title="Video Studio ‚Äî Stable", layout="wide")
TMP_DIR = os.path.join(tempfile.gettempdir(), "streamlit_video_studio")
os.makedirs(TMP_DIR, exist_ok=True)
MAX_SAFE_SECONDS = 180  # default recommended max clip length for Cloud; user can override but warned
REENCODE_FPS = 24
REENCODE_RESOLUTION = (1280, 720)  # default target resolution

# === Helpers ===

def run_cmd(cmd):
    try:
        res = subprocess.run(cmd, shell=False, stdout=subprocess.PIPE, stderr=subprocess.PIPE, timeout=30)
        return res.returncode, res.stdout.decode('utf-8', errors='ignore'), res.stderr.decode('utf-8', errors='ignore')
    except Exception as e:
        return 1, '', str(e)


def ffmpeg_exists():
    return shutil.which('ffmpeg') is not None


def ffprobe_exists():
    return shutil.which('ffprobe') is not None


def probe_video(path):
    # Use ffprobe if available to get stream info
    if not ffprobe_exists():
        return None
    cmd = ['ffprobe', '-v', 'error', '-show_entries', 'format=duration:stream=index,codec_name,codec_type,width,height,avg_frame_rate', '-of', 'json', path]
    code, out, err = run_cmd(cmd)
    if code != 0:
        return None
    try:
        return json.loads(out)
    except Exception:
        return None


def reencode_video(in_path, out_path, fps=REENCODE_FPS, resolution=REENCODE_RESOLUTION):
    # Use ffmpeg to re-encode and normalize fps/resolution/codec
    if not ffmpeg_exists():
        raise RuntimeError('ffmpeg not found on server. Please install ffmpeg.')
    width, height = resolution
    cmd = [
        'ffmpeg', '-y', '-i', in_path,
        '-vf', f'scale={width}:{height}',
        '-r', str(fps),
        '-c:v', 'libx264',
        '-preset', 'veryfast',
        '-crf', '23',
        '-c:a', 'aac',
        '-b:a', '128k',
        out_path
    ]
    code, out, err = run_cmd(cmd)
    if code != 0:
        raise RuntimeError(f'ffmpeg failed: {err[:400]}')
    return out_path


def save_uploaded_video(uploaded_file) -> str:
    if uploaded_file is None:
        return None
    ext = os.path.splitext(uploaded_file.name)[1]
    fname = f"upload_{uuid.uuid4().hex}{ext}"
    fpath = os.path.join(TMP_DIR, fname)
    with open(fpath, "wb") as f:
        f.write(uploaded_file.getbuffer())
    # Quick safety: if file is very large, warn
    size_mb = os.path.getsize(fpath) / (1024*1024)
    if size_mb > 200:
        st.warning(f"Uploaded file is large ({size_mb:.1f} MB). Processing may be slow on Streamlit Community Cloud.")
    return fpath


def read_video_clip(path) -> VideoFileClip:
    try:
        clip = VideoFileClip(path)
        return clip
    except Exception as e:
        st.error(f"Kh√¥ng th·ªÉ m·ªü video: {e}")
        return None


def write_clip_to_file(clip: VideoFileClip, filename: str, reencode=False) -> str:
    out_path = os.path.join(TMP_DIR, filename)
    try:
        if reencode:
            tmp = os.path.join(TMP_DIR, f"tmp_reencode_{uuid.uuid4().hex}.mp4")
            clip.write_videofile(tmp, codec="libx264", audio_codec="aac", threads=0, verbose=False, logger=None)
            # then run ffmpeg normalized re-encode
            reencode_video(tmp, out_path)
            os.remove(tmp)
        else:
            # Prefer using ffmpeg wrapper for robustness
            clip.write_videofile(out_path, codec="libx264", audio_codec="aac", threads=0, verbose=False, logger=None)
        return out_path
    except Exception as e:
        st.error(f"L·ªói khi xu·∫•t file: {e}")
        return None


def make_download_button(file_path, label="Download"):
    with open(file_path, "rb") as f:
        data = f.read()
    b64 = base64.b64encode(data).decode()
    href = f"data:application/octet-stream;base64,{b64}"
    filename = os.path.basename(file_path)
    st.markdown(f"<a href='{href}' download='{filename}' class='btn'>{label}</a>", unsafe_allow_html=True)

# === Recorder (WebRTC) with safer handling ===
class Recorder(VideoTransformerBase):
    def __init__(self) -> None:
        self.frames = []
        self.recording = False
        self.max_frames = 20 * MAX_SAFE_SECONDS  # fps cap assumption

    def recv(self, frame: av.VideoFrame) -> av.VideoFrame:
        try:
            if self.recording and len(self.frames) < self.max_frames:
                img = frame.to_ndarray(format="bgr24")
                self.frames.append(img)
            return frame
        except Exception:
            return frame

    def start_recording(self):
        self.frames = []
        self.recording = True

    def stop_and_save(self) -> str:
        self.recording = False
        if not self.frames:
            return None
        try:
            fps = 20
            arr = np.stack(self.frames)
            from moviepy.video.io.ImageSequenceClip import ImageSequenceClip
            clip = ImageSequenceClip(list(arr), fps=fps)
            filename = f"webcam_{uuid.uuid4().hex}.mp4"
            out_path = os.path.join(TMP_DIR, filename)
            clip.write_videofile(out_path, codec="libx264", audio=False, verbose=False, logger=None)
            return out_path
        except Exception as e:
            st.error(f"L·ªói khi l∆∞u video webcam: {e}")
            return None

# === UI & Pages ===

# CSS
st.markdown(
    """
    <style>
    .main > .block-container{max-width:1200px}
    .big-title{font-size:36px;font-weight:700;margin-bottom:6px}
    .muted{color:#6c757d}
    .feature-card{background:linear-gradient(180deg,#ffffff,#f7f9fb);padding:18px;border-radius:12px;box-shadow:0 6px 20px rgba(22,28,37,0.06);}
    .btn{display:inline-block;padding:8px 14px;border-radius:8px;border:0;background:#0b74de;color:white}
    .small{font-size:12px}
    </style>
    """,
    unsafe_allow_html=True,
)

st.sidebar.title("Video Studio ‚Äî Stable")
page = st.sidebar.radio("Ch·ªçn trang", ["Home", "Editor", "Library", "Diagnostics", "Deploy"])

# Initialize session state containers
st.session_state.setdefault('library', [])

# --- Home ---
if page == 'Home':
    st.markdown("<div class='big-title'>Video Studio ‚Äî Quay & Ch·ªânh s·ª≠a (Stable)</div>", unsafe_allow_html=True)
    st.markdown("Ghi webcam realtime, upload, trim, merge, re-encode v√† t·∫£i xu·ªëng. Phi√™n b·∫£n n√†y th√™m trang Diagnostics v√† t·ª± ƒë·ªông re-encode ƒë·ªÉ gi·∫£m l·ªói codec.")
    st.markdown("---")
    left, right = st.columns([2,3])
    with left:
        st.subheader("Ghi webcam realtime")
        rtc_config = RTCConfiguration({"iceServers": [{"urls": ["stun:stun.l.google.com:19302"]}]})
        webrtc_ctx = webrtc_streamer(
            key="webcam",
            mode="sendrecv",
            rtc_configuration=rtc_config,
            video_transformer_factory=Recorder,
            media_stream_constraints={"video": True, "audio": False},
            async_processing=True,
            in_thread=True,
        )
        col_r1, col_r2 = st.columns(2)
        with col_r1:
            if st.button("B·∫Øt ƒë·∫ßu ghi"):
                if webrtc_ctx.video_transformer:
                    webrtc_ctx.video_transformer.start_recording()
                    st.success("ƒêang ghi...")
                else:
                    st.error("Kh√¥ng th·ªÉ b·∫Øt ƒë·∫ßu ghi: transformer ch∆∞a s·∫µn s√†ng.")
        with col_r2:
            if st.button("D·ª´ng & L∆∞u"):
                if webrtc_ctx.video_transformer:
                    out = webrtc_ctx.video_transformer.stop_and_save()
                    if out:
                        # Normalize using re-encode to standard container/codec
                        norm = os.path.join(TMP_DIR, f"norm_{uuid.uuid4().hex}.mp4")
                        try:
                            reencode_video(out, norm)
                            os.remove(out)
                            st.session_state.setdefault("library", []).append(norm)
                            st.success(f"ƒê√£ l∆∞u: {os.path.basename(norm)}")
                        except Exception as e:
                            st.error(f"L∆∞u file th·∫•t b·∫°i: {e}")
                else:
                    st.error("Transformer ch∆∞a s·∫µn s√†ng.")

    with right:
        st.subheader("Quay m√†n h√¨nh (Client-side) ‚Äî Fallback & H∆∞·ªõng d·∫´n")
        st.markdown("H·ªá th·ªëng s·∫Ω m·ªü m·ªôt widget JS ƒë·ªÉ quay m√†n h√¨nh trong tr√¨nh duy·ªát. N·∫øu tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£, b·∫°n s·∫Ω th·∫•y th√¥ng b√°o.")
        screen_recorder_html = r"""
        <div>
        <button id='start'>Start Recording Screen</button>
        <button id='stop' disabled>Stop & Download</button>
        <div id='status' style='margin-top:8px;color:#444;'></div>
        <script>
        let mediaRecorder;
        let recordedChunks = [];
        const startBtn = document.getElementById('start');
        const stopBtn = document.getElementById('stop');
        const status = document.getElementById('status');
        function supported(){ return !!(navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia); }
        if(!supported()){ status.innerText = 'Screen recording not supported in this browser. Use Chrome/Edge for best results.'; startBtn.disabled=true; }
        startBtn.onclick = async () => {
          try{
            const stream = await navigator.mediaDevices.getDisplayMedia({video:true,audio:true});
            recordedChunks = [];
            mediaRecorder = new MediaRecorder(stream);
            mediaRecorder.ondataavailable = e => { if (e.data.size>0) recordedChunks.push(e.data); };
            mediaRecorder.onstop = e => {
              const blob = new Blob(recordedChunks, {type: 'video/webm'});
              const url = URL.createObjectURL(blob);
              const a = document.createElement('a');
              a.style.display='none';
              a.href = url;
              a.download = 'screen_record_'+Date.now()+'.webm';
              document.body.appendChild(a);
              a.click();
              URL.revokeObjectURL(url);
            };
            mediaRecorder.start();
            status.innerText = 'Recording... Press Stop to finish.';
            startBtn.disabled=true; stopBtn.disabled=false;
          }catch(err){ status.innerText = 'Permission denied or error: '+err; }
        };
        stopBtn.onclick = () => { if (mediaRecorder) { mediaRecorder.stop(); startBtn.disabled=false; stopBtn.disabled=true; status.innerText='Saved to your Downloads.'; } };
        </script>
        """
        st.components.v1.html(screen_recorder_html, height=160)

# --- Library Page ---
elif page == 'Library':
    st.header('Library')
    lib = st.session_state.get('library', [])
    if not lib:
        st.info('Library tr·ªëng. Ghi webcam ho·∫∑c upload video ƒë·ªÉ b·∫Øt ƒë·∫ßu.')
    else:
        for i, path in enumerate(lib[::-1]):
            idx = len(lib)-1-i
            cols = st.columns([1,4,2])
            with cols[0]:
                try:
                    thumb = VideoFileClip(path).get_frame(0)
                    st.image(Image.fromarray(thumb), width=120)
                except Exception:
                    st.write('üìπ')
            with cols[1]:
                st.markdown(f"**{os.path.basename(path)}**")
                try:
                    clip = VideoFileClip(path)
                    st.markdown(f"Duration: {clip.duration:.1f}s ‚Äî Size: {os.path.getsize(path)/(1024*1024):.1f}MB")
                except Exception as e:
                    st.markdown(f"Could not open clip: {e}")
            with cols[2]:
                if st.button('Edit', key=f'edit_{idx}'):
                    st.session_state['current_edit'] = path
                if st.button('Download', key=f'dl_{idx}'):
                    make_download_button(path, label='Download')
                if st.button('Delete', key=f'del_{idx}'):
                    try:
                        os.remove(path)
                        st.session_state['library'].pop(idx)
                        st.experimental_rerun()
                    except Exception as e:
                        st.error(f'Delete failed: {e}')

    st.markdown('---')
    st.subheader('Upload new video')
    uploaded = st.file_uploader('Drop or choose a video', type=['mp4','mov','webm','mkv','avi'])
    if uploaded is not None:
        path = save_uploaded_video(uploaded)
        if path:
            # Probe and normalize if needed
            probe = probe_video(path)
            if probe is None:
                st.info('ffprobe not available ‚Äî skipping auto-probe. Consider using Diagnostics page to install ffmpeg/ffprobe.')
            else:
                st.write('Probed video streams:')
                st.json(probe)
            st.session_state.setdefault('library', []).append(path)
            st.success(f'Uploaded: {os.path.basename(path)}')

# --- Editor Page ---
elif page == 'Editor':
    st.header('Editor')
    current = st.session_state.get('current_edit')
    if not current:
        st.info('Ch·ªçn m·ªôt clip trong Library ƒë·ªÉ m·ªü Editor.')
    else:
        clip = read_video_clip(current)
        if clip:
            st.video(current)
            st.markdown('**Basic operations**')
            start_t = st.number_input('Start (s)', min_value=0.0, max_value=float(clip.duration), value=0.0, step=0.1)
            end_t = st.number_input('End (s)', min_value=0.0, max_value=float(clip.duration), value=float(clip.duration), step=0.1)
            reverse = st.checkbox('Reverse')
            speed = st.slider('Speed (0.25x - 3x)', min_value=0.25, max_value=3.0, value=1.0, step=0.05)
            bgm = st.file_uploader('Background music (mp3/wav)', type=['mp3','wav'], key='bgm2')
            watermark = st.text_input('Watermark text')
            filters = st.multiselect('Quick filters', options=['Gray','Mirror','Crop center','Blur soft'])
            reencode_opt = st.checkbox('Normalize & Re-encode for max compatibility (recommended)', value=True)

            if st.button('Apply & Export'):
                try:
                    out_clip = clip.subclip(start_t, end_t)
                    if speed != 1.0:
                        out_clip = out_clip.fx(vfx.speedx, speed)
                    if reverse:
                        out_clip = out_clip.fx(vfx.time_mirror)
                    if 'Gray' in filters:
                        out_clip = out_clip.fx(vfx.blackwhite)
                    if 'Mirror' in filters:
                        out_clip = out_clip.fx(vfx.mirror_x)
                    if 'Crop center' in filters:
                        w,h = out_clip.size
                        out_clip = crop(out_clip, x1=w*0.08, y1=h*0.08, x2=w*0.92, y2=h*0.92)
                    if watermark.strip():
                        from moviepy.editor import TextClip, CompositeVideoClip
                        txtclip = TextClip(watermark, fontsize=24, color='white').set_pos(('right','bottom')).set_duration(out_clip.duration)
                        out_clip = CompositeVideoClip([out_clip, txtclip])
                    if bgm is not None:
                        bpath = save_uploaded_video(bgm)
                        aud = AudioFileClip(bpath).volumex(0.6)
                        out_clip = out_clip.set_audio(aud)

                    filename = f"edited_{uuid.uuid4().hex}.mp4"
                    # If long or high resolution, warn
                    if out_clip.duration > MAX_SAFE_SECONDS:
                        st.warning('Clip long ‚Äî processing may be slow on Streamlit Community Cloud. Consider trimming or run locally.')
                    out_path = write_clip_to_file(out_clip, filename, reencode=reencode_opt)
                    if out_path:
                        # Final normalization using ffmpeg if requested
                        if reencode_opt and ffmpeg_exists():
                            norm_path = os.path.join(TMP_DIR, f"norm_{uuid.uuid4().hex}.mp4")
                            try:
                                reencode_video(out_path, norm_path)
                                os.remove(out_path)
                                out_path = norm_path
                            except Exception as e:
                                st.warning(f'Normalization failed: {e}')
                        st.session_state.setdefault('library', []).append(out_path)
                        st.success('Export complete')
                        make_download_button(out_path, 'Download edited video')
                except Exception as e:
                    st.error(f'Processing error: {e}')

# --- Diagnostics Page ---
elif page == 'Diagnostics':
    st.header('Diagnostics & System Check')
    st.markdown('This page runs a mix of server-side and client-side checks to help ensure compatibility on Streamlit Community Cloud.')

    st.subheader('Server-side checks')
    col1, col2 = st.columns(2)
    with col1:
        st.markdown('**Python**')
        st.write(sys.version)
        st.markdown('**MoviePy version**')
        try:
            import moviepy
            st.write(moviepy.__version__)
        except Exception:
            st.error('MoviePy not installed / import failed')
        st.markdown('**ffmpeg**')
        if ffmpeg_exists():
            code,out,err = run_cmd(['ffmpeg','-version'])
            st.text(out.split('
')[0])
        else:
            st.error('ffmpeg not found on server. On Streamlit Community Cloud you may need to use an image that includes ffmpeg or contact support.')
    with col2:
        st.markdown('**ffprobe**')
        if ffprobe_exists():
            code,out,err = run_cmd(['ffprobe','-version'])
            st.text(out.split('
')[0])
        else:
            st.warning('ffprobe not found ‚Äî probing features limited')
        st.markdown('**Temporary directory**')
        st.write(TMP_DIR)
        st.markdown('Files in temp (latest 10)')
        try:
            files = sorted([os.path.join(TMP_DIR,f) for f in os.listdir(TMP_DIR)], key=os.path.getmtime, reverse=True)[:10]
            st.write([os.path.basename(f) + f' ({os.path.getsize(f)/(1024*1024):.1f}MB)' for f in files])
        except Exception:
            st.write('No files')

    st.markdown('---')
    st.subheader('Client-side checks (browser)')
    st.markdown('The following script will attempt to probe browser support for camera and screen recording (it runs in your browser). It cannot bypass permissions ‚Äî the browser will ask you to allow camera/mic.')

    client_check_html = r"""
    <div>
    <button id='check'>Run Client Check</button>
    <pre id='out' style='background:#f6f8fa;padding:8px;border-radius:6px;max-height:240px;overflow:auto;'></pre>
    <script>
    const btn = document.getElementById('check');
    const out = document.getElementById('out');
    function log(s){ out.innerText += s + '
'; }
    btn.onclick = async () => {
      out.innerText = '';
      log('UserAgent: ' + navigator.userAgent);
      log('navigator.mediaDevices: ' + !!navigator.mediaDevices);
      if(navigator.mediaDevices){
        try{
          await navigator.mediaDevices.getUserMedia({video:true});
          log('Camera access: allowed');
        }catch(e){ log('Camera access: denied or unavailable: ' + e); }
      }
      log('Screen capture support: ' + !!(navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia));
      log('MediaRecorder support: ' + !!window.MediaRecorder);
      log('WebRTC RTCPeerConnection: ' + !!window.RTCPeerConnection);
      log('End of client check.');
    };
    </script>
    """
    st.components.v1.html(client_check_html, height=300)

    st.markdown('---')
    st.subheader('Video probe example')
    st.markdown('If you have ffprobe available, upload a short sample video to probe codecs and streams:')
    sample = st.file_uploader('Upload sample', type=['mp4','webm','mov','mkv'])
    if sample is not None:
        path = save_uploaded_video(sample)
        if path:
            probe = probe_video(path)
            if probe:
                st.json(probe)
            else:
                st.warning('Probe unavailable. ffprobe not installed or file not readable.')

# --- Deploy Page (instructions for Streamlit Community Cloud) ---
elif page == 'Deploy':
    st.header('Deploy to Streamlit Community Cloud')
    st.markdown('Follow these steps to deploy this app to Streamlit Community Cloud:')
    st.markdown('1. Create a new public GitHub repo and push this project (streamlit_video_studio.py + requirements.txt).')
    st.markdown('2. In your repo, include the `requirements.txt` file with dependencies. Example below (a more complete file is in the repo):')
    st.code('''
streamlit
streamlit-webrtc
moviepy
numpy
pillow
av
SpeechRecognition
pydub
''')
    st.markdown('3. On Streamlit Cloud, click New app ‚Üí connect repo ‚Üí deploy. If ffmpeg is missing at runtime, the Diagnostics page will say so.')
    st.markdown('4. Note: Streamlit Cloud has resource limits ‚Äî prefer clips under 2 minutes. For heavy workloads, use a VPS or Render with more CPU/RAM.')
    st.markdown('---')
    st.markdown('Optional: add a `packages.txt` file in the repository root (for apt packages like ffmpeg) containing:')
    st.code('''
ffmpeg
''')
    st.markdown('If Streamlit Community Cloud honors `packages.txt`, ffmpeg will be installed at build time. If not, use an alternative hosting that supports apt packages.')

# --- Cleanup action available globally ---
st.sidebar.markdown('---')
if st.sidebar.button('Cleanup temp files'):
    try:
        shutil.rmtree(TMP_DIR)
        os.makedirs(TMP_DIR, exist_ok=True)
        st.sidebar.success('Temp files cleared')
    except Exception as e:
        st.sidebar.error(f'Cleanup failed: {e}')

# --- End ---

